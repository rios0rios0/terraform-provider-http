---
# generated by https://github.com/hashicorp/terraform-plugin-docs
page_title: "http_request Resource - terraform-provider-http"
subcategory: ""
description: |-
  Represents an HTTP request resource, allowing configuration of various HTTP request parameters and capturing the response details.
---

# http_request (Resource)

Represents an HTTP request resource, allowing configuration of various HTTP request parameters and capturing the response details.

## Example Usage

```terraform
# 1) Basic GET
resource "http_request" "get_example" {
  method  = "GET"
  path    = "/posts/1"
  headers = {
    "Accept" = "application/json"
  }
  is_response_body_json   = true
  response_body_id_filter = "$.id"
}

# 2) Resource-level base URL (allows different APIs per resource)
resource "http_request" "different_api" {
  method   = "GET"
  path     = "/posts/1"
  base_url = "https://api.example.com"  # Override provider URL
  
  headers = {
    "Accept" = "application/json"
  }
  is_response_body_json   = true
  response_body_id_filter = "$.id"
}

# 3) Resource-level authentication (per-resource credentials)
resource "http_request" "with_auth" {
  method   = "GET"
  path     = "/protected/data"
  base_url = "https://secure-api.example.com"
  
  basic_auth = {
    username = "api-user"
    password = "secret-key"
  }
  
  is_response_body_json   = true
  response_body_id_filter = "$.id"
}

# 4) Resource-level TLS configuration
resource "http_request" "insecure_api" {
  method     = "GET"
  path       = "/data"
  base_url   = "https://self-signed.example.com"
  ignore_tls = true  # Skip TLS verification for this resource
  
  is_response_body_json   = true
  response_body_id_filter = "$.id"
}

# 5) Using count with different APIs (solves the original issue!)
variable "apis" {
  default = [
    {
      name     = "api1"
      base_url = "https://api1.example.com"
      path     = "/users/1"
    },
    {
      name     = "api2" 
      base_url = "https://api2.example.com"
      path     = "/profiles/1"
    }
  ]
}

resource "http_request" "multi_api_calls" {
  count = length(var.apis)
  
  method   = "GET"
  path     = var.apis[count.index].path
  base_url = var.apis[count.index].base_url
  
  is_response_body_json   = true
  response_body_id_filter = "$.id"
}

# 6) POST create + enable real DELETE using JSONPath token in delete_path
# When `is_delete_enabled = true` and `delete_path` contains JSONPath tokens (e.g. $.id),
# the provider resolves the token(s) against the JSON `response_body` from create and stores
# the computed value in `delete_resolved_path`. On `terraform destroy`, it will send the
# selected `delete_method` (default DELETE) to `delete_resolved_path`.
#
# NOTE: Changing any delete_* field (is_delete_enabled, delete_method, delete_path,
# delete_headers, delete_request_body) does NOT trigger resource replacement.
# These fields only affect behavior during `terraform destroy`.
resource "http_request" "create_then_delete" {
  method  = "POST"
  path    = "/posts"
  headers = {
    "Content-Type" = "application/json"
    "Accept"       = "application/json"
  }
  request_body = jsonencode({
    title  = "hello world"
    body   = "example payload"
    userId = 123
  })

  is_response_body_json   = true
  response_body_id_filter = "$.id"

  # ---- destroy controls (changes do NOT trigger replacement) ----
  is_delete_enabled = true
  # Resolve to something like /posts/101 using id from the POST response
  delete_path = "/posts/$.id"
}

# 7) POST create + SOFT DELETE via POST with custom headers and body
# Some APIs require a non-DELETE verb or a specific body to "archive"/"deactivate".
resource "http_request" "create_then_soft_delete" {
  method  = "POST"
  path    = "/posts"
  headers = {
    "Content-Type" = "application/json"
    "Accept"       = "application/json"
  }
  request_body = jsonencode({
    title  = "soft delete example"
    body   = "created then archived"
    userId = 456
  })

  is_response_body_json   = true
  response_body_id_filter = "$.id"

  # ---- destroy controls (changes do NOT trigger replacement) ----
  is_delete_enabled   = true
  delete_method       = "POST"
  delete_path         = "/posts/$.id/archive"
  delete_headers = {
    "X-Force-Archive" = "true"
  }
  delete_request_body = jsonencode({
    reason = "terraform destroy"
    actor  = "automation"
  })
}

# 8) GET with query_parameters (echoed into the request URL)
resource "http_request" "with_query_params" {
  method = "GET"
  path   = "/comments"

  query_parameters = {
    postId = "1"
    q      = "foo"
  }

  headers = {
    "Accept" = "application/json"
  }
  is_response_body_json   = true
  response_body_id_filter = "$[0].id"
}

# 9) Ignore volatile inputs (headers or JSON fragments)
# Use `ignore_changes` to prevent resource replacement when specific fields change.
# This is useful for fields that contain dynamic values like UUIDs, timestamps, etc.
# Supports:
#   - Full attributes: "request_body", "headers"
#   - Map keys: "headers.X-Correlation-Id"
#   - JSON paths: "request_body.metadata.trace_id"
#
# NOTE: Delete fields (is_delete_enabled, delete_method, delete_path, delete_headers,
# delete_request_body) do NOT need to be in ignore_changes - they never trigger
# replacement because they only affect `terraform destroy` behavior.
resource "http_request" "idempotent_post" {
  method = "POST"
  path   = "/posts"
  headers = {
    "Content-Type"      = "application/json"
    "X-Correlation-Id"  = uuid()
  }

  request_body = jsonencode({
    title    = "immutable values"
    metadata = {
      trace_id = uuid()
      owner    = "terraform"
    }
  })

  ignore_changes = [
    "headers.X-Correlation-Id",
    "request_body.metadata.trace_id",
  ]
}
```

<!-- schema generated by tfplugindocs -->
## Schema

### Required

- `method` (String) The HTTP method to be used for the request (e.g., GET, POST, PUT, DELETE).
- `path` (String) The URL path for the HTTP request. This should be a relative path (e.g., /api/v1/resource).

### Optional

- `base_url` (String) The base URL for this specific HTTP request. When specified, this overrides the provider-level URL configuration. This allows for different APIs to be used within the same configuration.
- `basic_auth` (Attributes) Credentials for basic authentication for this specific request. When specified, this overrides the provider-level basic authentication configuration. (see [below for nested schema](#nestedatt--basic_auth))
- `delete_headers` (Map of String) Headers to send only during deletion.
- `delete_method` (String) HTTP method to use during deletion (e.g., DELETE, POST). Defaults to DELETE.
- `delete_path` (String) Path to call during deletion. Supports inline JSONPath tokens like "/posts/$.data.id" evaluated against the `response_body` from create.
- `delete_request_body` (String) Body to send only during deletion.
- `headers` (Map of String) A map of HTTP headers to include in the request. Each key-value pair represents a header name and its corresponding value.
- `ignore_changes` (Set of String) Optional list of attribute paths that should not force replacement when they change. Supports top-level attributes (e.g. `request_body`), individual map entries (e.g. `headers.X-Correlation-Id`), and JSON paths inside request bodies (e.g. `request_body.metadata.trace_id`).
- `ignore_tls` (Boolean) A boolean flag to indicate whether TLS certificate verification should be ignored for this specific request. When specified, this overrides the provider-level ignore_tls configuration.
- `is_delete_enabled` (Boolean) Enables remote deletion during `terraform destroy`. If true and no delete_path is provided, a DELETE will be sent to the original `path`.
- `is_response_body_json` (Boolean) A boolean flag indicating whether the response body is expected to be in JSON format.
- `query_parameters` (Map of String) Optional query parameters to append to the request path
- `request_body` (String) The body content to be sent with the HTTP request. This is typically used for POST and PUT requests.
- `response_body_id_filter` (String) A JSONPath filter used to extract a specific ID from the JSON response body. This is useful for identifying unique elements within the response.

### Read-Only

- `delete_resolved_path` (String) The `delete_path` with JSONPath tokens resolved from the create response, when possible.
- `id` (String) A unique identifier for the resource. Format: `<RANDOM UUID>/<PARAMETERS ENCODED IN BASE64>`. This is generated by encoding the entire model (excluding the ID itself) in Base64 format.
- `response_body` (String) The raw body content returned by the server in response to the request.
- `response_body_id` (String) The extracted ID from the JSON response body, based on the provided `response_body_id_filter`. This is only populated if `is_response_body_json` is true.
- `response_body_json` (Map of String) The response body parsed as a Terraform map object. Nested items can be accessed using dot notation (e.g., "response_body_json["nested.item.value"]").
- `response_code` (Number) The HTTP status code returned by the server in response to the request (e.g., 200 for success, 404 for not found).

<a id="nestedatt--basic_auth"></a>
### Nested Schema for `basic_auth`

Required:

- `password` (String, Sensitive) The password for basic authentication.
- `username` (String) The username for basic authentication.

## Import

Import is supported using the following syntax:

```shell
# generate a random UUID
uuid="00000000-0000-0000-00000-000000000000"

# convert the desired block (http_request.example1) to JSON:
# {
#   "method": "GET",
#   "path": "/posts/1",
#   "headers": {
#     "Content-Type": "application/json"
#   },
#   "is_response_body_json": true,
#   "response_body_id_filter": "$.id"
# }

# encode it to base64
base64="eyJtZXRob2QiOiAiR0VUIiwgInBhdGgiOiAiL3Bvc3RzLzEiLCAiaGVhZGVycyI6IHsiQ29udGVudC1UeXBlIjogImFwcGxpY2F0aW9uL2pzb24ifSwgImlzX3Jlc3BvbnNlX2JvZHlfanNvbiI6IHRydWUsICJyZXNwb25zZV9ib2R5X2lkX2ZpbHRlciI6ICIkLmlkIn0="

# import by using UUID/B64
terraform import http_request.example1 "$uuid/$base64"
```
